Chapter_02
=============
### KISS 원칙
keep it short and simple <br/>
기능을 만들 때, 응용프로그램 코드를 한 개의 클래스로 구현 <br/>
아직 파일이 존재하지 않거나 파일 내용을 파싱할 때 발생하는 문제를 해결하기 위한 예외 처리를 신경 쓰지 않음 <br/>

### 코드 유지보수성과 안티 패턴
* 구현하는 코드가 가졌으면 하는 속성 목록
  - 특정 기능을 담당하는 코드를 쉽게 찾을 수 있어야 함
  - 코드가 어떤 일을 수행하는지 쉽게 이해할 수 있어야 함
  - 새로운 기능을 쉽게 추가하거나 기존 기능을 쉽게 제거할 수 있어야 함
  - **캡슐화**가 잘 되어 있어야 함. 즉 코드 사용자에게는 세부 구현 내용이 감춰져 있으므로 
  사용자가 쉽게 코드를 이해하고, 기능을 바꿀 수 있어야 함
* 안티 패턴
  - 새로운 요구 사항이 생길 때마다 복사, 붙여넣기로 이를 해결하려면 다음과 같은 문제가 생김.
  이는 효과적이지 않은 해결 방법으로 잘 알려져 있으며, **안티 패턴**이라고 부름
    + 한 개의 거대한 **갓 클래스** 때문에 코드를 이해하기 어렵다.
    + **코드 중복** 때문에 코드가 불안정하고 변화에 쉽게 망가진다.
* 갓 클래스
  - 하나의 거대한 클래스가 모든 일을 수행함
  - 기존 코드 로직을 갱신해야 할 때, 코드를 찾기 어려움
  - 갓 클래스를 피하기 위해 **단일 책임 원칙(SRP)**을 지켜야 함
* 코드 중복
  - 코드가 하드코딩돼 있으면 기존의 기능을 바꾸려면 여러 곳의 코드를 바꿔야 하고 버그가 발생할 가능성이 커짐
  > DRY 원칙: don't repeat yourself 의 약자로 반복을 제거하면 로직을 바꿔도 여러 곳의 코드를 바꿔야 할 필요성이 없어짐

#### 결론 
* 코드를 간결하게 유지하는 것도 중요하지만, KISS 원칙을 남용하지 않아야 함

### 단일 책임 원칙
- **단일 책임 원칙(SRP)** 은 쉽게 관리하고 유지보수하는 코드를 구현하는 데 도움을 주는 포괄적인 소프트웨어
개발 지침
- SRP를 적용법
  * 한 클래스는 한 기능만 책임진다.
  * 클래스가 바뀌어야 하는 이유는 오직 하나여야 한다.
    + 코드가 바뀌는 이유가 한 가지가 아니라면, 여러 장소에서 코드 변경이 발생하므로 코드 유지보수가 어려워짐
    또한 코드를 이해하고 바꾸기 어렵게 만드는 요인이 됨
> **BankTransactionAnalyzerSimple** 는 어떻게 바뀌어야 할까?
> 1. 입력 읽기
> 2. 주어진 형식의 입력 파싱
> 3. 결과 처리
> 4. 결과 요약 리포트

### 응집도
- 응집도는 **어떻게 관련되어 있는지**를 가리킴
- 응집도는 클래스나 메서드의 책임이 서로 얼마나 강하게 연결되어 있는지를 측정함
- 응집도는 소프트웨어의 복잡성을 유추하는 데 도움을 줌
- 높은 응집도는 개발자의 목표이고, 누구나 쉽게 코드를 찾고, 이해하고, 사용할 수 있도록 만들고 싶어 함
- BankStatementCSVParser의 응집도는 높음. 이 클래스에서 CSV 데이터를 파싱하는 작업과 관련된 두 메서드를 한 그룹
으로 만들었기 때문임
- 보통 응집도 개념은 클래스(클래스 수준 응집도)에 적용하지만, 이를 메서드(메서드 수준 응집도)에도 적용할 수 있음
  - 프로그램의 진입점인 BankStatementAnalyzer 클래스를 살펴보면, 이 클래스는 파서, 계산, 화면으로 결과 전송 등
  응용프로그램의 다양한 부분을 연결한다는 사실을 알 수 있음. 하지만 현재 계산 작업을 하는 로직은 클래스 내의 정적
  메서드로 선언되어 있음. 이클래스에 정의된 계산 관련 작업은 파싱이나 결과 전송과는 직접적인 관련이 없으므로 응집도가
  떨어지는 클래스 사례임.
  - 대신 계산 연산을 BankStatementProcessor 라는 별도의 클래스로 추출함. 또한 모든 연산에서 메서드 인수인 입출금 내역
  목록을 공유하므로 이를 클래스의 필드로 만듦. 결과적을 메서드 시그니처는 훨씬 단순해지고 BankStatementProcessor의
  응집도도 개선됨. 덕분에 응용프로그램의 다른 부분에서 BankStatementAnalyzer 전체 클래스를 의존하지 않고도
  BankStatementProcessor의 메서드를 사용할 수 있음.

#### 클래스 수준 응집도
- 실무에서는 일반적으로 다음과 같은 여섯 가지 방법으로 그룹화함
  * 기능
  * 정보
  * 유틸리티
  * 논리
  * 순차
  * 시간
- 그룹화하는 메서드의 관련성이 약하면 응집도가 낮아짐

##### 기능
  - BankStatementCSVParser를 구현할 때 기능이 비슷한 메서드를 그룹화했다. parseFrom()과 parseLinesFrom()은 CSV형식의
행을 파싱한다. 내부적으로 parseLinesFrom() 메서드는 parseFrom() 메서드를 사용한다. 이렇게 함께 사용ㅎ나는 메서드를
그룹화하면 찾기도 쉽고 이해하기도 쉬우므로 응집도를 높인다. 다만 기능 응집은 한 개의 메서드를 갖는 클래스를 너무
과도하게 만들려는 경향이 발생할 수 있다는 약점이 있다. 간단한 클래스를 과도하게 만들면 그만큼 생각해야 할 클래스가
많아지므로 코드가 장황해지고 복잡해진다.
##### 정보
  - 같은 데이터나 도메인 객체를 처리하는 메서드를 그룹화하는 방법도 있다. 예를 들면 BankTransaction 객체를 만들고,
읽고, 갱신하고, 삭제하는 기능(CRUD 연산)이 필요해 이런 기능만 제공하는 클래스를 만들어야 한다.BankStatementDAO는
네 개의 다른 메서드를 관련 정보로 응집하는 클래스를 구현한다. 메서드의 바디는 아직 구현하지 않았으므로 모든 메서드는
UnsupportedOperationException 예외를 던진다.
  - 정보 응집은 여러 기능을 그룹화하면서, 필요한 기능을 포함하는 클래스 전체를 디펜던시로 추가한다는 약점이 있다.
##### 유틸리티
  - 때로는 관련성이 없는 메서드를 한 클래스로 포함시켜야 한다. 특히 메서드가 어디에 속해야 할지 어려울 때는
만능 스위스 군용 칼과 같은 **유틸리티 클래스**에 추가하기도 한다.
  - 유틸리티 클래스 사용은 낮은 응집도로 이어지므로 자제해야 한다. 메서드가 서로 연관성이 없으므로 클래스 전체의 기능을
추론하기가 어렵다. 더욱이 유틸리티 클래스에서는 특징을 찾기가 어렵다. 쉽게 코드를 찾고, 어떻게 사용할 수 있는지 이해하기
쉽도록 만들어야 한다. 하지만 유틸리티 클래스는 관련성이 없는 여러 메서드를 명확하지 않은 기준으로 그룹화하므로 이 원칙을
거스른다.
##### 논리
  - CSV, JSON, XML의 자료를 파싱하는 코드를 구현한 BankStatementFullParser 에서 세 개의 메서드는 '파싱'이라는 논리로
그룹화되었다. 하지만 이들은 본질적으로 다르며 네 메서드는 서로 관련이 없다. 또한 이렇게 그룹화하면, 클래스는 세 가지
책임을 갖게 되므로 이전에 배웠던 SRP를 위배한다. 결과적으로 이 방법은 권장하지 않는다.
##### 순차
  - 파일을 읽고, 파싱하고, 처리하고, 정보를 저장하는 메서드들을 한 클래스로 그룹화한다. 파일을 읽은 결과는 파싱의
입력이 되고, 파싱의 결과는 처리 과정의 입력이 되는 등의 과정이 반복된다.
  - 입출력이 순차적으로 흐르는 것을 순차 응집이라 부른다. 순차 응집은 적용하면 한 클래스를 바꿔야 할 여러 이유가
존재하므로 SRP을 위배한다. 더욱이 데이터를 처리, 요약, 저장하는 방법이 다양하므로 결국 이 기법은 클래스를 순식간에
복잡하게 만든다. 따라서 각 책임을 개별적으로 응집된 클래스로 분리하는 것이 더 좋은 방법이다.
##### 시간
  - 시간 응집 클래스는 여러 연산 중 시간과 관련된 연산을 그룹화한다. 어떤 처리 작업을 시작하기 전과 뒤에 초기화,
뒷정리 작업(예를 들어 데이터베이스 연결과 종료)을 담당하는 메서드를 포함하는 클래스가 그 예다. 초기화 작업은 다른 
작업과 관련이 없지만, 다른 작업보다 먼저 실행되어야 한다.

| 응집도 수준       | 장점              | 단점                  |
|--------------|-----------------|---------------------|
| 기능(높은 응집도)   | 이해하기 쉬움         | 너무 단순한 클래스 생성       |
| 정보(중간 응집도)   | 유지보수하기 쉬움       | 불필요한 디펜던시           |
| 순차(중간 응집도)   | 관련 동작을 찾기 쉬움    | SRP를 위배할 수 있음       |
| 논리(중간 응집도)   | 높은 수준의 카테고리화 제공 | SRP를 위배할 수 있음       |
| 유틸리티(낮은 응집도) | 간단히 추가 가능       | 클래스의 책임을 파악하기 어려움   |
| 시간(낮은 응집도)   | 판단 불가           | 각 동작을 이해하고 사용하기 어려움 |

#### 메서드 수준 응집도
- 응집도 원칙은 클래스뿐만 아니라 메서드에도 적용할 수 있다. 메서드가 다양한 기능을 수행할수록 메서드가 어떤 동작을
하는지 이해하기가 점점 어려워진다. 즉 메서드가 연관이 없는 여러 일을 처리한다면 응집도가 낮아진다.응집도가 낮은 메서드는
여러 책임을 포함하기 때문에 각 책임을 테스트하기가 어렵고, 메서드의 책임도 테스트하기가 어렵다. 일반적으로 클래스나
메서드 파라미터의 여러 필드를 바꾸는 if/else 블록이 여러 개 포함되어 있다면, 이는 응집도에 문제가 있음을 의미하므로
응집도가 높은 더 작은 조각으로 메서드를 분리해야 한다.

### 결합도
- 코드를 구현할 때 고려해야 할 또 다른 중요한 특성으로 **결합도**가 있다.
- 응집도는 클래스, 패키지, 메서드 등의 동작이 얼마나 관련되어 있는가를 가리키는 반면, 결합도는 한 기능이 다른 클래스에
얼 마나 의존하고 있는지를 가늠한다.
- 결합도는 어떤 클래스를 구현하는 데 얼마나 많은 지식(다른 클래스)을 참조했는가로 설명할 수 있다. 더 많은 클래스를 참조
했다면 기능을 변경할 때 그만큼 유연성이 떨어진다. 어떤 클래스의 코드를 바꾸면 이 클래스에 의존하는 모든 클래스가 영향을
받는다.
- 시계를 생각하면 결합도를 쉽게 이해할 수 있다. 시계가 어떻게 동작하는지 몰라도 시간을 알아내는 데 문제가 없다. 즉 사람은
시계 내부 구조에 의존하지 않기 때문이다. 따라서 시계 내부 구조를 바꾸더라도 사람이 시계를 읽는 데 영향을 받지 않는다. 
이는 두 가지 임무인 인터페이스와 구현이 서로 결합되지 않았기(decoupled) 때문이다 
- 결합도는 코드가 서로 **어떻게 의존하는지**와 관련이 있는 척도다. BankStatementAnalyzer 는 BankStatementCSVParser
클래스에 의존한다. 만약 JSON 항목으로 인코딩된 거래 내역을 파싱할 수 있도록 파서 구현을 바꾸려면 어떻게 해야 할까?
XML 항목을 지원하려면 어떻게 해야 할까? 성가신 리팩터링 작업을 해야 한다. 인터페이스를 이용해 여러 컴포넌트의 결합도를
제거할 수 있다. 인터페이스를 이용하면 요구 사항이 바뀌더라도 유연성을 유지할 수 있다.
- BankStatementCSVParser 는 BankStatementParser를 구현한다
- BankStatementAnalyzer와 특정 BankStatementCSVParser 구현의 결합을 어떻게 제거할 수 있을까? 이때 인터페이스를 사용한다.
BankTransactionParser 를 인수로 받는 analyze() 메서드를 새로 만들어 특정 구현에 종속되지 않도록 클래스를 개선한다.
- 보통 코드를 구현할 때는 **결합도를 낮춰야**한다. 이는 코드의 다양한 컴포넌트가 내부와 세부 구현에 의존하지 않아야
함을 의미한다. 반대로 **높은 결합도**는 무조건 피해야 한다.


### 테스트
#### 테스트 자동화
- 수동 테스트에만 의존하면 안 된다. 자동화된 테스트에서는 사람의 조작 없이 여러 테스트가 포함된 스위트(suite)가 자동으로
실행된다. 즉 우리가 코드를 바꿨을 때, 지정된 테스트가 빠르게 실행되므로 소프트웨어가 예상하지 못한 문제를 일으키지 않고
제대로 동작할 거라는 확신을 조금 더 가질 수 있다.
- 테스트 자동화의 장점
  * 확신
    + 소프트웨어가 규격 사양과 일치하며 동작하는지를 테스트해 고객의 요구 사항을 충족하고 있다는 사실을 더욱 확신할 수
    있다.
  * 변화에도 튼튼함 유지
    + 코드베이스에 수백만 행의 코드가 있다면 동료가 코드를 수정했을 때, 문제가 발생하지 않을 거라는 걸 어떻게 확신할 수
    있을까? 자동화된 테스트 스위트가 있다면 바꾼 코드로 인해 새로운 버그가 발생하지 않았음을 확인하는 데 큰 도움이 된다.
  * 프로그램 이해도
    + 테스트 자동화는 소스코드의 프로젝트에서 다양한 컴포넌트가 어떻게 동작하는지 이해하는 데 도움을 준다. 테스트는
    다양한 컴포넌트의 디펜던시와 이들이 어떻게 상호작용하는지를 명확하게 드러낸다. 따라서 소프트웨서의 전체 개요를 빨리
    파악할 수 있다. 우리가 새 프로젝트에 투입되었다면 다양한 컴포넌트의 개요를 어디서부터 확인할 수 있을까? 바로 자동화된
    테스트부터 살펴보면 좋다

#### 제이유닛 사용하기
- 메서드나 작은 클래스처럼 작고 고립된 단위(유닛unit)를 테스트하는 것을 **유닛 테스트unit test**라고 한다.
- BankStatementCSVParserTest 클래스의 shouldParseOneCorrectLine 테스트에서는 다음 세 가지 일이 벌어지고 있다.
  1. 테스트의 콘텍스트를 설정한다. 여기서는 파싱할 행을 설정한다.
  2. 동작을 실행한다. 여기서는 입력 행을 파싱한다.
  3. 예상된 결과를 어서션으로 지정한다. 여기서는 날짜, 금액, 설명이 제대로 파싱되었는지 확인한다.
  > 이와 같은 유닛 테스트 설정의 세 단계 패턴을 **Given-When-Then** 공식이라 부른다.

#### 코드 커버리지
- **코드 커버리지**는 테스트 집합이 소프트웨어의 소스코드를 얼마나 테스트했는가를 가리키는 척도다. 커버리지가 높을수록
예상하지 못한 버그가 발생할 확률이 낮아지므로 되도록 커버리지를 높이는 것을 목표로 삼아야 한다.
- 보통 70에서 90퍼센트를 목표로 정할 것을 권한다. 실제 100퍼센트의 코드 커버리지를 달성하는 것은 어렵고 무모한 일이다.
코드에는 게터, 세터 같이 테스트할 필요가 없는 메서드가 많기 때문이다.
- 코드 커버리지가 높다고 해서 우리가 소프트웨어를 잘 테스트하고 있음을 의미하는 것은 아니다. 코드 커버리지는 우리가
테스트하지 않은 부분이 남아 있음을 알려주는 역할에 지나지 않기 때문에 테스트의 품질과는 아무 관련이 없다. 우리가 간단한
테스트로 코드를 커버했을 수는 있지만, 실제 문제가 많이 발생하는 상황을 테스트하지 않았을 수도 있기 때문이다.
- 얼마나 많은 구문의 코드를 커버했는지를 의미하는 **구문 커버리지**가 있다. 이 기법은 분기문(if, while, for)을 한 구문으로
취급해버리는 치명적인 약점이 있다. 사실 분기문에는 가능한 여러 개의 경로가 있기 때문이다. 따라서 구문 커버리지보다
각 분기문을 확인하는 **분기 커버리지**를 사용하는 것이 좋다.

## 총정리
- 갓 클래스와 코드 중복은 코드를 추론하고 유지보수하기 어렵게 만드는 요인이다.
- 단일 책임 원칙은 관리하고 유지보수하기 쉬운 코드를 구현하는 데 도움을 준다.
- 응집도는 클래스나 메서드의 책임이 얼마나 강하게 연관되어 있는지를 가리킨다.
- 결합도는 클래스가 다른 코드 부분에 얼마나 의존하고 있는지를 가리킨다.
- 높은 응집도와 낮은 결합도는 유지보수가 가능한 코드가 가져야 할 특징이다.
- 자동화된 테스트 스위트는 소프트웨어가 올바로 동작하며, 코드를 수정해도 잘 동작할 것임을 확신할 수 있고, 프로그램을
쉽게 이해할 수 있도록 도움을 준다.
- 자바 테스트 프레임워크 제이유닛을 확용해 메서드와 클래스의 동작을 테스트하는 유닛 테스트를 만든다.
- 테스트를 쉽게 이해할 수 있도록 Given-When-Then 패턴으로 유닛 테스트를 세 부분으로 분리하는 것이 좋다.